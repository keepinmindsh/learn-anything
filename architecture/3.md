# 처리율 제한 장치의 설계 

네트워크 시스템에서 처리율 제한 장치는 클라이너트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치이다.  
HTTP로 예를 들면 이 장치는 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다.  

### 몇가지 사례 

- 사용자는 초당 2회 이상 새 글을 올릴 수 없다. 
- 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다. 
- 같은 디바이스로는 주당 5회 이상 리워드를 요청할 수 없다. 
- 트위터는 3시간동안 300개의 트윗만 올릴 수 있다록 제한하고 있다. 
- 구글 독스 API는 사용자당 분당 300회의 READ 요청만 허용한다.
- 처리율 제한은 제 3자 API에 사용료를 지불하고 있는 회사들에게는 아주 중요하다. 
- 서버의 과부하를 막는다. 

## 필요사항 

- 설정된 처리율을 초과하는 요청은 정확하게 제한한다. 
- 낮은 응답시간: 이 처리율 제한 장치는 HTTP 응답 시간에 나쁜 영향을 주어서는 곤란하다. 
- 가능한 한 적은 메모리를 써야 한다. 
- 분산형 처리율 제한: 하나의 처리율 제한 장치를 여러 서버나 프로세스에 공유할 수 있어야 한다. 
- 예외처리: 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 부여주어야 한다. 
- 높은 결함 감내성: 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안 된다. 

### 처리율 제한 장치의 위치 

- 서버 API
- 서버 API 내의 미들웨어 
- 클라우드 기반의 API Gateway 


### 처리율 제한 알고리즘 

- 토큰 버킷
- 누출 버킷
- 고정 윈도 카운터
- 이동 윈도 로그
- 이동 윈도 카운터

# 토큰 버킷 알고리즘 / Token Bucket Algorithm

![토큰 버킷 알고리즘](https://github.com/lines-code/learn-anything/blob/master/architecture/assets/token_bucket_algorythm.png)

토큰 버킷은 지정된 용량을 가지는 컨테이이며, 

- 만약 토큰 버킷이 가지는 용량이 5라면, 5개의 요청이 들어오면 토큰 버킷 내에 존재하는 토큰을 모두 소모하게 된다.  
- 5개 이후의 들어오는 요청은 추가로 제공할 수 있는 토큰이 없기 때문에 버려진다. 
- 이후 refill 시간에 의해서 토큰이 추가로 버킷에 공급되면, 추가적인 요청을 받을 수 있게 된다. 

## 중요 인자 

- 버킷 크기 : 버킷에 담을 수 있는 최대 토큰 개수  
- 토큰 공급률 : 초당 몇 개의 토큰이 버킷에 공급되는가 

## 사용예시

- API 요청마다 설정하는 방식으로 많이 활용됨 
  - 예를 들어, 초당 2개의 요청을 허용하는 API가 있다고 가정하면, 버킷 크기는 2, 토큰 공급률은 2로 설정할 수 있다.
- IP 주소별로 처리율 제한을 적용해야 한다면 IP 주소마다 버킷을 하나씩 할당해야 한다. 
- 시스템의 처리율을 초당 10,000개 요청으로 제한하고 싶다면, 모든 요청이 하나의 버킷에 공유되도록 할 수 있다.

## 장단점 

- 장점
  - 구현이 쉽다. 
  - 메모리 사용 측면에도 효율적이다.
  - 짧은 시간에 집중되는 트래픽도 처리 가능하다. 
- 단점 
  - 2개의 인자에 대한 조정 및 관리에 대해서 값을 튜닝하는 과정이 까다로울 수 있다.  

# 누출 버킷 알고리즘 / Leaky Bucket Algorithm

![누출 버킷 알고리즘](https://github.com/lines-code/learn-anything/blob/master/architecture/assets/leakey_bucket_algorython.png)

토큰 버킷과 동일하게 지정된 토큰 공급 방식을 가지지만, 차이점은 요청 처리율이 고정되어 있다. 
누출 버킷 알고리즘은 FIFO 큐로 구현된다. 

- 요청이 도착하면 큐가 가득차있는지 본다. 빈자리가 있는 경우 큐에 요청을 추가한다. 
- 큐가 가득 차 있는 경우에는 새 요청은 버린다. 
- **지정된 시간**마다 큐에서 요청을 꺼내어 처리한다. 

## 중요인자 

- 버킷크기 : 큐 사이즈와 같은 값이다. 큐에는 처리될 항목들이 보관된다. 
- 처리율 : 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값이다. 보통은 초단위로 표현된다. 

## 장단점 

- 장점
  - 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다. 
  - 고정된 처리율을 갖고 있기 때문에 안정적 출력을 필요한 경우 적합하다.
- 단점 
  - 단시간에 트래픽이 몰리는 경우에는 오래된 요청이 많이 쌓이게 되고, 그 요청들을 제때 처리하지 못하게 되면 최신요청들은 버려지게 된다. 
  - 두 개 인자를 갖고 있는데, 이것들을 올바르게 튜닝하기가 까다로울수 있다.

# 고정 윈도 카운터 알고리즘 / Fixed Window Counter Algorithm

![고정 윈도우 알고리즘](https://github.com/lines-code/learn-anything/blob/master/architecture/assets/fixed_window_counter.png?raw=true)

- 타임라인이 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 붙인다. 
- 요청이 접수될 때 마다 이 카운터의 값은 1씩 증가한다. 
- 이 카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 요청은 윈도가 열릴 때까지 버려진다.

## 고정 윈도 카운터 알고리즘의 단점

![고정 윈도우 카운터 알고리즘](https://github.com/lines-code/learn-anything/blob/master/architecture/assets/fixed_window_counter_problem.png)

이 알고리즘의 가장 큰 문제는 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다는 점이다.  
이미지를 보면 윈도간의 경계 부근에 요청이 몰리는 경우, 윈도 A와 윈도 B의 카운터가 모두 5로 설정되어 있다면, 10개의 요청을 처리할 수 있게 된다.

## 장단점 

- 장점
  - 메모리 효율이 좋다
  - 이해하기 쉽다 
  - 윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정 트래픽 패ㅔ턴을 처리하기에 적합하다. 
- 단점
  - 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰리는 경우, 기대했던 시스템의 처리한도보다 많은 요청을 처리하게 된다.   

# 이동 윈도 로깅 알고리즘 / Sliding Window Logging Algorithm

이동 윈도 로깅 알고리즘은 고정 윈도 카운터 알고리즘의 문제를 해결하기 위해서 사용될 수 있다. 

- 요청의 타임스탬프를 추적한다. 타임스탬프 데이터는 보통 레디스의 정렬 집합같은 캐시에 보관한다. 
- 새 요청이 오면 만료된 타임스탬프는 제거한다. 만료된 타임스탬프는 그 값이 현재 윈도의 시작지점보다 오래된 타임스탬프를 말한다. 
- 새 요청의 타임 스탬프를 로그에 추가한다. 
- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다. 그렇지 않는 경우에는 처리를 거부한다.

## 처리율 제한 장치가 요청을 처리할 때는 다음과 같은 과정을 거친다.

1. 요청이 들어오면 현재 시간을 기록한다.
2. 현재 시간을 기준으로 윈도의 시작 시간을 계산한다.
3. 윈도 시작 시간 이후의 타임스탬프를 가진 요청들을 모두 제거한다.
4. 현재 윈도에 남아있는 요청의 개수를 계산한다.
5. 현재 윈도에 남아있는 요청의 개수가 허용된 처리율보다 작거나 같으면 요청을 처리한다.
6. 현재 윈도에 남아있는 요청의 개수가 허용된 처리율보다 크면 요청을 거부한다.
7. 현재 요청의 타임스탬프를 로그에 추가한다.
8. 요청이 처리되면 응답을 반환한다.

## 장단점

- 장점
  - 해당 알고리즘이 구현하는 처리율 제한 메커니즘은 아주 정교하다. 어느 순간의 윈도를 보더라도, 허용되는 개수는 시스템의 처리율 한도를 넘지 않는다. 
- 단점
  - 다량의 메무리를 사용하는데, 이는 거부된 요청의 타임 스탬프도 보관하기 때문이다. 

# 이동 윈도 카운터 알고리즘 / Sliding Window Counter Algorithm

![이동 윈도 알고리즘](https://github.com/lines-code/learn-anything/blob/master/architecture/assets/sliding_window_counter.png)

이동 윈도 카운터 알고리즘은 고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 것이다.  

- 현재 1분간의 요청수 + 직전 1분간의 요청수 * 이동윈도와 직전 1분이 겹치는 비율
- 이 공식에 따르면 현재 윈도에 들어 있는 요청은 3 + 5 * 70% = 3 + 3.5 = 6.5개로 계산된다. 
  반올림해서 쓸 수도 있고 내림하여 쓸수도 있는데, 내림하여 쓰면 그 값은 6이다.

## 징딘점

- 장점
  - 이전 시간대의 평균 처리율에 따라 현재 윈도 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다. 
  - 메모리 효율이 좋다. 
- 단점
  - 직전 시간대에 요청한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다. 
    하지만 이 문제는 생각만큼 심간한 것은 아닌데, 클라우드 플레어가 실시했던 실험에 따르면 40억개의 요청 가운데 시스템의 실제 상태와 맞지않게 허용되거나 버려진 요청은 0.0003%에 불과했다.